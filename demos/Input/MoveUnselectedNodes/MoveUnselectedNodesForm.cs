/****************************************************************************
 ** 
 ** This demo file is part of yFiles.NET 5.2.
 ** Copyright (c) 2000-2019 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles.NET functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles.NET version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles.NET powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles.NET
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.Drawing;
using System.IO;
using System.Windows.Forms;
using Demo.yFiles.Graph.Input.MoveUnselectedNodes.Properties;
using yWorks.Controls;
using yWorks.Controls.Input;
using yWorks.Geometry;
using yWorks.Graph;
using yWorks.Graph.LabelModels;
using yWorks.Graph.Styles;

namespace Demo.yFiles.Graph.Input.MoveUnselectedNodes
{
  /// <summary>
  /// Shows how to use and configure the <see cref="GraphEditorInputMode.MoveUnselectedInputMode"/>.
  /// </summary>
  /// <remarks>
  /// This special move input mode can be used to move nodes without selecting them first.
  /// </remarks>
  public partial class MoveUnselectedNodesForm
  {
    /// <summary>
    /// Automatically generated by Visual Studio.
    /// Wires up the UI components and adds a 
    /// <see cref="GraphControl"/> to the form.
    /// </summary>
    public MoveUnselectedNodesForm() {
      InitializeComponent();
      RegisterToolStripCommands();
      try {
        description.LoadFile(new MemoryStream(Resources.description), RichTextBoxStreamType.RichText);
      } catch (MissingMethodException) {
        // Workaround for https://github.com/microsoft/msbuild/issues/4581
        description.Text = "The description is not available with this version of .NET Core.";
      }
    }

    private void RegisterToolStripCommands() {
      zoomInButton.SetCommand(Commands.IncreaseZoom, graphControl);
      zoomOutButton.SetCommand(Commands.DecreaseZoom, graphControl);
      fitContentButton.SetCommand(Commands.FitContent, graphControl);
    }

    /// <summary>
    /// Initializes the graph and the input mode.
    /// </summary>
    /// <seealso cref="InitializeInputModes"/>
    /// <seealso cref="InitializeGraph"/>
    protected override void OnLoad(EventArgs e) {
      base.OnLoad(e);
      // initialize the graph
      InitializeGraph();

      // initialize the input mode
      InitializeInputModes();
      cmbMode.SelectedIndex = 0;
      GraphControl.FitGraphBounds();
    }
    
    /// <summary>
    /// Creates and registers the input modes.
    /// </summary>
    protected virtual void InitializeInputModes()
    {
      var mode = new GraphEditorInputMode();

      // Always add a label to the newly created nodes
      mode.NodeCreator = (context, graph, location, parent) =>
      {
        var node = graph.CreateNode(location);
        graph.AddLabel(node, "Node");
        return node;
      };

      // The original MoveInputMode is only active when the 'Classic Mode' toggle button is checked
      mode.MoveInputMode.Enabled = btnClassic.Checked;

      // Enable the MoveUnselectedInputMode:
      mode.MoveUnselectedInputMode.Enabled = true;
      // configure the recognizer to also respect the IsRecognized method
      mode.MoveUnselectedInputMode.PressedRecognizer = mode.MoveUnselectedInputMode.PressedRecognizer.And(IsRecognized);
      mode.MoveUnselectedInputMode.HoverRecognizer = mode.MoveUnselectedInputMode.HoverRecognizer.And(IsRecognized);

      graphControl.InputMode = mode;
    }

    /// <summary>
    /// A custom <see cref="EventRecognizer"/> to be used as modifier recognizer.
    /// </summary>
    /// <remarks>
    /// Has to return true if the move input mode is allowed to move a node.
    /// </remarks>
    private bool IsRecognized(object eventSource, EventArgs eventArg) {
      // return the value according to the Mode combo box
      switch (cmbMode.SelectedIndex) {
        case 0: // always
        case 2: // on top (this is handled by custom IHitTestable)
          // the same as the unmodified MoveUnselectedInputMode;
          return true;
        case 1: // shift is not pressed
          return !KeyEventRecognizers.ShiftPressed(eventSource, eventArg);
        case 3: // if enabled
          return btnEnable.Checked;
        default:
          return false;
      }
    }

    /// <summary>
    /// Initializes the graph instance setting default styles
    /// and creating a small sample graph.
    /// </summary>
    protected virtual void InitializeGraph() {
      // set the default node style
      Graph.NodeDefaults.Style = new PanelNodeStyle
      {
        Color = Color.Orange,
        LabelInsetsColor = Color.Gold,
        Insets = new InsetsD(5,20,5,5)
      };
      Graph.NodeDefaults.Size = new SizeD(60,80);
      Graph.NodeDefaults.Labels.LayoutParameter = InteriorLabelModel.North;

      // Create a sample node
      Graph.AddLabel(Graph.CreateNode(), "Node");
    }

    /// <summary>
    /// Returns the GraphControl instance used in the form.
    /// </summary>
    public GraphControl GraphControl {
      get { return graphControl; }
    }

    /// <summary>
    /// Gets the currently registered IGraph instance from the GraphControl.
    /// </summary>
    public IGraph Graph {
      get { return GraphControl.Graph; }
    }


    private void OnClassicClicked(object sender, EventArgs e) {
      ((GraphEditorInputMode) graphControl.InputMode).MoveInputMode.Enabled = btnClassic.Checked;
    }

    // Called when the mode combo box has changed: 
    // if necessary it changes the hit testable for the move input mode
    private void OnMoveModeChanged(object sender, EventArgs e) {
      var moveUnselectedInputMode = graphControl != null ? ((GraphEditorInputMode) graphControl.InputMode).MoveUnselectedInputMode : null;
      if (moveUnselectedInputMode == null) {
        return;
      }
      if (cmbMode.SelectedIndex == 2) {
        // mode 2 (only top region): set a custom hit testable which detects hits
        // only at the top of the nodes
        moveUnselectedInputMode.HitTestable = new TopInsetsHitTestable((GraphEditorInputMode) graphControl.InputMode);
      }
      else if (moveUnselectedInputMode.HitTestable is TopInsetsHitTestable) {
        // all other modes: if a TopInsetsHitTestable is the current hit testable
        // restore the original hit testable
        moveUnselectedInputMode.HitTestable = GraphEditorInputMode.UnselectedMovablesHitTestable;
      }
      // mode 3: Enable the Move button
      btnEnable.Enabled = cmbMode.SelectedIndex == 3;
    }

    /// <summary>
    /// An IHitTestable implementation which detects hits only on top insets of a node.
    /// </summary>
    private class TopInsetsHitTestable : IHitTestable
    {
      private readonly GraphEditorInputMode inputMode;

      public TopInsetsHitTestable(GraphEditorInputMode inputMode) {
        this.inputMode = inputMode;
      }

      /// <summary>
      /// Test whether the given location is a valid hit.
      /// </summary>
      /// <remarks>
      /// The hit is considered as valid if the location lies inside a node's top insets.
      /// </remarks>
      /// <param name="context">The current input mode context.</param>
      /// <param name="location">The location to test.</param>
      /// <returns></returns>
      public bool IsHit(IInputModeContext context, PointD location) {
        // Get the current hit tester from the input mode context
        IHitTester<IModelItem> enumerator = inputMode.InputModeContext.Lookup(typeof(IHitTester<IModelItem>)) as IHitTester<IModelItem>;
        if (enumerator != null) {
          // get an enumerator over all elements at the given location
          var hits = enumerator.EnumerateHits(inputMode.InputModeContext, location);
          foreach (var item in hits) {
            // if the element is a node and its lookup returns an INodeInsetsProvider
            var node = item as INode;
            if (node != null) {
              var insetsProvider = node.Lookup<INodeInsetsProvider>();
              if (insetsProvider != null) {
                // determine whether the given location lies inside the top insets
                InsetsD insets = insetsProvider.GetInsets(node);
                if (new RectD(node.Layout.X, node.Layout.Y, node.Layout.Width, insets.Top).Contains(location)) {
                  // if so: return true
                  return true;
                }
                // else: continue iteration
              }
            }
          }
        }
        // no hits found: return false
        return false;
      }
    }

    #region Application Start

    /// <summary>
    /// The main entry point for the demo.
    /// </summary>
    [STAThread]
    private static void Main() {
      Application.EnableVisualStyles();
      Application.SetCompatibleTextRenderingDefault(false);
      Application.Run(new MoveUnselectedNodesForm());
    }

    #endregion
  }
}
