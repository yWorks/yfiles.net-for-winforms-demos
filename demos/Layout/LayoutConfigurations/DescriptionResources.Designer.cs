/****************************************************************************
 ** 
 ** This demo file is part of yFiles.NET 5.3.
 ** Copyright (c) 2000-2020 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles.NET functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles.NET version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles.NET powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles.NET
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Demo.yFiles.Layout.Configurations {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class DescriptionResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal DescriptionResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Demo.yFiles.Layout.Configurations.DescriptionResources", typeof(DescriptionResources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sa200\sl276\slmult1\cf1\f0\fs18\lang1033 The balloon layout is a tree layout that positions the subtrees in a radial fashion around their root nodes. It is ideally suited for larger trees.\cf0\f1\fs22\lang1031\par
        ///}
        ///.
        /// </summary>
        internal static string Balloon {
            get {
                return ResourceManager.GetString("Balloon", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 Orthogonal bus-style edge routing combines the (likely confusing) mass of edges in parts of a diagram where each node is connected to each other node in a concise, orthogonal tree-like structure. This algorithm does not change the positions of the nodes.\par
        ///The algorithm aims to find ro [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Bus_Router {
            get {
                return ResourceManager.GetString("Bus_Router", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sa200\sl276\slmult1\cf1\f0\fs18\lang1033 Channel edge router uses a rather fast but simple algorithm for finding orthogonal edge routes. As other routing algorithms it does not change the positions of the nodes. Compared to polyline and orthogonal edge router, edge segments can be very close to each other and edges may a [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Channel_Router {
            get {
                return ResourceManager.GetString("Channel_Router", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}{\f2\fnil\fcharset2 Symbol;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The circular layout style emphasizes group and tree structures within a network. It creates node partitions by analyzing the connectivity structure of the network, and arranges the partitions as separate circles. The circles themselves are arranged in a radial  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Circular {
            get {
                return ResourceManager.GetString("Circular", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The component layout algorithm arranges the connected components of a graph. It can use any other layout style to arrange each component separately, and then arranges the components as such.\par
        ///In this demo, the arrangement of each component is just kept as it is.\cf0\f1\fs22\lang1031\p [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Components {
            get {
                return ResourceManager.GetString("Components", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}{\f2\fnil\fcharset2 Symbol;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The hierarchical layout style highlights the main direction or flow of a directed graph. The layout algorithm places the nodes of a graph in hierarchically arranged layers such that the (majority of) its edges follows the overall orientation, for example, top-t [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Hierarchic {
            get {
                return ResourceManager.GetString("Hierarchic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sa200\sl276\slmult1\cf1\f0\fs18\lang1033 This algorithm finds good positions for the labels of nodes and edges. Typically, a label should be placed near the item it belongs to and it should not overlap with other labels. Optionally, overlaps with nodes and edges can be avoided as well.\cf0\f1\fs22\lang1031\par
        ///}
        ///.
        /// </summary>
        internal static string Labeling {
            get {
                return ResourceManager.GetString("Labeling", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}{\f2\fnil\fcharset2 Symbol;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The organic layout style is based on the force-directed layout paradigm. This algorithm simulates physical forces and rearranges the positions of the nodes in such a way that the sum of the forces emitted by the nodes and the edges reaches a (local) minimum.\pa [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Organic {
            get {
                return ResourceManager.GetString("Organic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sa200\sl276\slmult1\cf1\f0\fs18\lang1033 The organic edge routing algorithm routes edges in soft curves to ensure that they do not overlap with nodes. It is especially well suited for non-orthogonal, organic or circular diagrams.\cf0\f1\fs22\lang1031\par
        ///}
        ///.
        /// </summary>
        internal static string Organic_Router {
            get {
                return ResourceManager.GetString("Organic_Router", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}{\f2\fnil\fcharset2 Symbol;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The orthogonal layout style is a multi-purpose layout style for undirected graphs. It is well suited for medium-sized sparse graphs, and produces compact drawings with no overlaps, few crossings, and few bends.\par
        ///It is especially fitted for application domai [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Orthogonal {
            get {
                return ResourceManager.GetString("Orthogonal", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sa200\sl276\slmult1\cf1\f0\fs18\lang1033 The parallel edge routing algorithm routes parallel edges which connect the same pair of nodes in a graph. It is often used as layout stage for other layout algorithms to handle the parallel edges for those.\cf0\f1\fs22\lang1031\par
        ///}
        ///.
        /// </summary>
        internal static string Parallel_Router {
            get {
                return ResourceManager.GetString("Parallel_Router", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 Partial layout arranges user-specified parts of a diagram, the so-called partial elements, while keeping the other parts fixed. It is related to incremental graph layout. This concept is a perfect fit for incremental scenarios where subsequently added parts should be arranged so that they [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Partial {
            get {
                return ResourceManager.GetString("Partial", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 Polyline edge routing calculates polyline edge paths for a diagram&apos;s edges. The positions of the nodes are not changed by this algorithm.\par
        ///Edges will be routed orthogonally, that is each edge path consists of horizontal and vertical segments, or octilinear. Octilinear means that the s [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Polyline_Router {
            get {
                return ResourceManager.GetString("Polyline_Router", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The radial layout arranges the nodes of a graph on concentric circles. Similar to hierarchic layouts, the overall flow of the graph is nicely visualized.\par
        ///This style is well suited for the visualization of directed graphs and tree-like structures.\cf0\f1\fs22\lang1031\par
        ///}
        ///.
        /// </summary>
        internal static string Radial {
            get {
                return ResourceManager.GetString("Radial", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sa200\sl276\slmult1\cf1\f0\fs18\lang1033 The series-parallel layout algorithm highlights the main direction or flow of a graph, similar to the hierarchic style. In comparison, this algorithm is usually faster but can be used only on special graphs, namely series-parallel graphs.\cf0\f1\fs22\lang1031\par
        ///}
        ///.
        /// </summary>
        internal static string Series_Parallel {
            get {
                return ResourceManager.GetString("Series_Parallel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The tabular layout style arranges the nodes in rows and columns. This is a very simple layout which is useful when nodes should be placed under/next to each other.\par
        ///Edges are ignored in this layout style. Their bends are removed.\cf0\f1\fs22\lang1031\par
        ///}
        ///.
        /// </summary>
        internal static string Tabular {
            get {
                return ResourceManager.GetString("Tabular", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Calibri;}{\f2\fnil\fcharset2 Symbol;}}
        ///{\colortbl ;\red0\green0\blue0;}
        ///{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
        ///\pard\sb150\sa150\cf1\f0\fs18\lang1033 The various flavors of the tree layout styles are great for highlighting child-parent relationships in graphs that form one or more trees, or trees with only few additional edges.\par
        ///The need to visualize directed or undirected trees arises in many applicatio [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Tree {
            get {
                return ResourceManager.GetString("Tree", resourceCulture);
            }
        }
    }
}
