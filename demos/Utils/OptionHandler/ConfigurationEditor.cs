/****************************************************************************
 ** 
 ** This demo file is part of yFiles.NET 5.6.
 ** Copyright (c) 2000-2024 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles.NET functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles.NET version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles.NET powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles.NET
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace Demo.yFiles.Toolkit.OptionHandler
{
  public partial class ConfigurationEditor : UserControl
  {
    /// <summary>
    /// The underlying configuration
    /// </summary>
    private object _configuration;

    // layouting information
    private readonly int topLevelGroupPaddingLeft;
    private readonly int topLevelGroupPaddingRight;
    private readonly int topLevelGroupPaddingTop;
    private readonly int topLevelGroupPaddingBottom;
    private readonly int gbPaddingTop;
    private readonly int gbPaddingBottom;
    private readonly int gbPaddingLeft;
    private readonly int gbPaddingRight;

    // flag whether the controls have already been created
    private bool initialized = false;

    // buffer of options and which controls correspond to them
    // this is needed when components are getting enabled or disabled through other controls 
    readonly Dictionary<Control, Option> optionBuffer = new Dictionary<Control, Option>();

    /// <summary>
    /// Automatically generated by Visual Studio.
    /// </summary>
    public ConfigurationEditor() {
      InitializeComponent();
      topLevelGroupPaddingLeft = topLevelGroupPaddingRight = topLevelGroupPaddingTop = topLevelGroupPaddingBottom = 20;
      gbPaddingTop = gbPaddingBottom = gbPaddingLeft = gbPaddingRight = 20;

      rootPanel.SizeChanged += RecomputeSizes;
    }

    /// <summary>
    /// The public configuration property that should be set with a configuration object,
    /// Will update view, when set.
    /// </summary>
    public void UpdateConfiguration(object configuration) {
      if (configuration == _configuration) {
        return;
      }
      _configuration = configuration;
      var optionGroup = new ConfigConverter().Convert(configuration);

      rootPanel.Controls.Clear();

      int Y = 0;
      Control control;
      foreach (var option in optionGroup.ChildOptions) {
        if (option is OptionGroup) {
          var container = AddTopLevelOptionGroup((OptionGroup) option);
          if (option.Name == "DescriptionGroup") {
            container.Panel2Collapsed = false;
          }
          control = container;
        } else {
          control = CreateControl(option);
          rootPanel.Controls.Add(control);
          control.Location = new Point(topLevelGroupPaddingLeft, Y);
        }
        rootPanel.Controls.Add(control);
        Y += control.Height;
      }

      RecomputeSizes(null, null);
      initialized = true;
    }

    /// <summary>
    /// Creates a control for the specified option. This may be a compound control, wrapped in a panel.
    /// </summary>
    /// <param name="option"></param>
    /// <returns></returns>
    private Control CreateControl(Option option) {
      //controls are wrapped in a panel to emulate WP-style labeled items
      var panel = new Panel() {
          Height = 20, Width = rootPanel.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight)
      };
      var label = new Label() {Text = option.Label, AutoSize = true, Dock = DockStyle.Fill};
      panel.Controls.Add(label);

      // create a control according to component type
      switch (option.ComponentType) {
        case ComponentTypes.Checkbox:
          var chkBox = new CheckBox() {Height = 20, Width = 20, Location = new Point(100, 0)};
          ReadCheckboxData(chkBox, option);
          chkBox.CheckStateChanged += ReevaluateAllControlStates;
          var binding = new Binding
              ("Checked", option, "Value", false, DataSourceUpdateMode.OnPropertyChanged);
          chkBox.DataBindings.Add(binding);
          panel.Controls.Add(chkBox);
          optionBuffer[chkBox] = option;
          return panel;

        case ComponentTypes.RadioButton:
        case ComponentTypes.Combobox:
          panel.Height = 25;
          var comboBox = new ComboBox() {Height = 20, Text = option.Label};
          comboBox.DataSource = option.EnumValues.ToList();
          comboBox.DisplayMember = "Name";
          comboBox.ValueMember = "Value";
          ReadComboboxData(comboBox, option);
          Binding comboBinding = new Binding
              ("SelectedValue", option, "Value", false, DataSourceUpdateMode.OnPropertyChanged);
          comboBox.DataBindings.Add(comboBinding);
          comboBox.SelectedIndexChanged += ReevaluateAllControlStates;
          comboBox.Dock = DockStyle.Right;
          comboBox.DropDownStyle = ComboBoxStyle.DropDownList;
          panel.Controls.Add(comboBox);
          comboBox.SizeChanged += (sender, args) => UpdatePanelHeight(panel);
          optionBuffer[comboBox] = option;
          return panel;

        case ComponentTypes.Slider:
          var numWidth = 50;
          panel.Height = 60;
          panel.Controls.Add(label);

          var trackBar = new TrackBar() {Text = option.Label, Location = new Point(0, 20),
              Minimum = (int) option.MinMax.Min,
              Maximum = (int) option.MinMax.Max,
              TickFrequency = 1,
              TickStyle = TickStyle.None
          };

          trackBar.Width = panel.Width - (topLevelGroupPaddingRight + topLevelGroupPaddingLeft + numWidth);
          trackBar.Enabled = option.IsEnabled;

          var numericField = new NumericUpDown() {
              Width = numWidth,
              Height = 40,
              Minimum = new decimal(option.MinMax.Min),
              Maximum = new decimal(option.MinMax.Max),
              Increment = new decimal(option.MinMax.Step.Equals(0) ? 1 : option.MinMax.Step)
          };

          var sliderBinding = new Binding
              ("Value", option, "Value", false, DataSourceUpdateMode.OnPropertyChanged);
          trackBar.DataBindings.Add(sliderBinding);
          var numericBinding = new Binding
              ("Value", option, "Value", false, DataSourceUpdateMode.OnPropertyChanged);

          
          // a trackbar can only increment in whole numbers, thus a scale factor is used
          var originalTickStep = option.MinMax.Step.Equals(0) ? 1 : option.MinMax.Step;
          if (originalTickStep < 1 && option.ValueType != typeof(int)) {
            var scaleFactor = 1 / originalTickStep;

            trackBar.Minimum = (int) (option.MinMax.Min * scaleFactor);
            trackBar.Maximum = (int) (option.MinMax.Max * scaleFactor);
            trackBar.TickFrequency = 1;

            sliderBinding.Parse += (sender, args) => {
              if (option.ValueType == typeof(int)) {
                var controlValue = (int) args.Value;
                args.Value = controlValue / scaleFactor;
              } else {
                var controlValue = (int) args.Value;
                double actualValue = controlValue / scaleFactor;
                args.Value = actualValue;
              }
            };
            sliderBinding.Format += (sender, args) => {
              if (args.Value.GetType() != typeof(int)) {
                var actualValue = (double) args.Value * scaleFactor;
                int controlValue = (int) actualValue;
                args.Value = controlValue;
              }
            };

            numericField.DecimalPlaces = 2;
            numericField.Increment = new decimal(option.MinMax.Step.Equals(0) ? 1 : option.MinMax.Step);
            // on the numeric field as well
            numericBinding.Parse += delegate (object sender, ConvertEventArgs args) {
              decimal inVal = (decimal) args.Value;
              args.Value = (double) inVal;
            };

          } else {
            // convert the numeric field as usual
            numericBinding.Parse += delegate(object sender, ConvertEventArgs args) {
              decimal inVal = (decimal) args.Value;
              args.Value = (int) inVal;

            };
          }

          numericField.DataBindings.Add(numericBinding);

          var sliderEnabledBinding = new Binding
              ("Enabled", option, "IsEnabled", false, DataSourceUpdateMode.Never);
          trackBar.DataBindings.Add(sliderEnabledBinding);

          panel.Controls.Add(trackBar);
          panel.Controls.Add(numericField);

          optionBuffer[trackBar] = option;
          optionBuffer[numericField] = option;

          return panel;

        case ComponentTypes.FormattedText:
          var block = new RichTextBox();
          block.WordWrap = true;
          block.Width = panel.Width;
          block.Rtf = option.Value as string;
          block.Height = block.GetPositionFromCharIndex(block.Text.Length - 1).Y;
          
          block.MouseWheel += delegate(object sender, MouseEventArgs args) {
            
            var nV = rootPanel.VerticalScroll.Value - args.Delta;
            if (nV > rootPanel.VerticalScroll.Minimum && nV <= rootPanel.VerticalScroll.Maximum) {
              rootPanel.VerticalScroll.Value = nV;
            }
          };
          return block;

        case ComponentTypes.Text:
          panel.Controls.Add(label);
          var text = new Label();
          text.Text = option.Value as string;
          panel.Controls.Add(text);
          return panel;

        case ComponentTypes.Spinner:
          var spinnerWidth = 40;
          var spinner = new NumericUpDown()
          {
              Width = spinnerWidth,
              Height = 40,
              Enabled = option.IsEnabled,
          };

          if (option.MinMax != null) {
            spinner.Minimum = (decimal) option.MinMax.Min;
            spinner.Maximum = (decimal) option.MinMax.Max;
            spinner.Increment = (decimal) option.MinMax.Step;
          }

          panel.Controls.Add(spinner);
          optionBuffer[spinner] = option;
          
          return panel; 

        default:
          panel.Controls.Add(new Label() {Text = "Missing Component - " + option.Name, Width = rootPanel.Width});
          return panel;
      }

    }

    private static void UpdatePanelHeight(Panel panel) {
      // Limit the label's width to the available space and calculate its new
      // height. If the text in the label wraps, the height will change.
      Label label = (Label) panel.Controls[0];
      ComboBox comboBox = (ComboBox) panel.Controls[1];
      var oldHeight = panel.Height;
      label.MaximumSize = new Size(panel.Width - comboBox.PreferredSize.Width, Int32.MaxValue);
      panel.Height = Math.Max(label.Height + 5, 25);

      // If the height has changed, move all subsequent controls by the change.
      var delta = panel.Height - oldHeight;
      if (delta != 0 && panel.Parent != null) {
        var collection = panel.Parent.Controls;
        var index = collection.IndexOf(panel);
        for (index++; index < collection.Count; index++) {
          var oldLocation = collection[index].Location;
          var newLocation = new Point(oldLocation.X, oldLocation.Y + delta);
          collection[index].Location = newLocation;
        }
      } 
    }

    /// <summary>
    ///  Creates a group box and it's children
    /// </summary>
    /// <param name="optionGroup"></param>
    /// <returns></returns>
    private Control CreateGroupBox(OptionGroup optionGroup) {
      GroupBox box = new GroupBox();
      box.Text = optionGroup.Label;
      box.Width = rootPanel.Width -
                  (gbPaddingLeft + gbPaddingRight + topLevelGroupPaddingLeft + topLevelGroupPaddingRight);
      var Y = box.Location.Y + gbPaddingTop;

      foreach (var child in optionGroup.ChildOptions) {
        Control groupChild = CreateControl(child);
        groupChild.Location = new Point(gbPaddingLeft, Y);
        groupChild.Width = rootPanel.Width -
                           (gbPaddingLeft + gbPaddingRight + topLevelGroupPaddingLeft + topLevelGroupPaddingRight);

        box.Controls.Add(groupChild);
        Y += groupChild.Height;
      }
      box.Height = Y + gbPaddingBottom;
      return box;
    }

    /// <summary>
    /// Creates a foldable top-level grouping and it's children
    /// </summary>
    /// <param name="optionGroup"></param>
    private SplitContainer AddTopLevelOptionGroup(OptionGroup optionGroup) {
      SplitContainer splitContainer = new SplitContainer();
      splitContainer.Orientation = Orientation.Horizontal;
      splitContainer.BackColor = Color.LightGray;
      splitContainer.Width =
          rootPanel.Width - (rootPanel.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight + 100));
      splitContainer.IsSplitterFixed = true;

      var groupLabelButton =
          new Label() {Text = "▶ " + optionGroup.Label, BackColor = Color.Gray, ForeColor = Color.White, Dock = DockStyle.Fill, TextAlign = ContentAlignment.MiddleLeft, AutoSize = false};
      groupLabelButton.Click += (sender, args) => {
        toggleHeaderCollapse(splitContainer);
      };
      splitContainer.Panel1.Click += (sender, args) => {
        toggleHeaderCollapse(splitContainer);
      };

      splitContainer.Panel1.Controls.Add(groupLabelButton);
      splitContainer.Panel1.BackColor = Color.Gray;
      splitContainer.Panel1.Size = new Size(rootPanel.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight), 30);
      splitContainer.Panel1.AutoSize = true;


      var Y = topLevelGroupPaddingTop;
      foreach (var option in (optionGroup).ChildOptions) {
        // a group containing more elements
        if (option.ComponentType == ComponentTypes.OptionGroup) {
          var optionControl = CreateGroupBox(option as OptionGroup);
          optionControl.Location = new Point(topLevelGroupPaddingLeft, Y);
          splitContainer.Panel2.Controls.Add(optionControl);
          Y += optionControl.Height;
        } else {
          // single elements
          var optionControl = CreateControl(option);
          splitContainer.Panel2.Controls.Add(optionControl);
          optionControl.Location = new Point(topLevelGroupPaddingLeft, Y);
          Y += optionControl.Height;
        }
      }

      splitContainer.Panel2.BackColor = Color.White;
      splitContainer.Panel1MinSize = 30;
      splitContainer.Panel2MinSize = 1;
      splitContainer.Panel2.AutoSize = true;

      splitContainer.FixedPanel = FixedPanel.Panel1;
      splitContainer.SplitterDistance = 10;
      splitContainer.MinimumSize = new Size(rootPanel.Width, 10);
      splitContainer.Size = new Size(rootPanel.Width, 10);
      splitContainer.Panel2Collapsed = true;

      if (optionGroup.Label == "Description") {
        if (splitContainer.Panel2.Controls[0] is RichTextBox) {
          // rtf boxes can be isolated
          RichTextBox text = (RichTextBox) splitContainer.Panel2.Controls[0];
          text.Width = rootPanel.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight);
          text.BorderStyle = BorderStyle.None;
          text.ScrollBars = RichTextBoxScrollBars.None;
          var content = text.Rtf;
          text.Text = String.Empty;
          ContentsResizedEventHandler text_OnContentsResized = null;
          text_OnContentsResized = delegate(object o, ContentsResizedEventArgs args) {
            text.Height = args.NewRectangle.Height;
            splitContainer.Height = topLevelGroupPaddingBottom + topLevelGroupPaddingTop + args.NewRectangle.Height;
            text.ContentsResized -= text_OnContentsResized;
          };
          text.ContentsResized += text_OnContentsResized;
          text.Rtf = content;
          
          toggleHeaderCollapse(splitContainer);
        }
      }
      return splitContainer;
    }


    private void toggleHeaderCollapse(SplitContainer splitContainer) {
      splitContainer.Panel2Collapsed = splitContainer.Panel2Collapsed ? false : true;
      if (splitContainer.Panel2Collapsed) {
        splitContainer.Size = new Size(rootPanel.Width, 30);
        var label = (Label) splitContainer.Panel1.Controls[0];
        label.Text = @"▶ " + label.Text.Substring(2);

      } else {
        splitContainer.Size = new Size(rootPanel.Width,
            splitContainer.Panel2.Height + topLevelGroupPaddingBottom + topLevelGroupPaddingTop);
        var label = (Label) splitContainer.Panel1.Controls[0];
        label.Text = @"▼ " + label.Text.Substring(2);
      }
    }


    /// <summary>
    /// Called when a setting is changed which may result in a control's Enabled property to change
    /// </summary>
    private void ReevaluateAllControlStates(object sender, EventArgs e) {
      if (!initialized) {
        return;
      }
      foreach (var pair in optionBuffer) {
        var control = pair.Key;
        var option = pair.Value;
        if (control != sender) {
          ReadState(control, option);
        }
      }
    }

    private void ReadState(Control control, Option option) {
      if (control.GetType() == typeof(CheckBox)) {
        var cb = control as CheckBox;
        ReadCheckboxData(cb, option);
      } else if (control.GetType() == typeof(ComboBox)) {
        var dd = (ComboBox) control;
        ReadComboboxData(dd, option);
      } else if (control.GetType() == typeof(TrackBar)) {
        var tb = (TrackBar) control;
        ReadSliderData(tb, option);
      } else if (control.GetType() == typeof(NumericUpDown)) {
        var nud = (NumericUpDown) control;
        ReadSpinnerData(nud, option);
      }
    }

    private void ReadSpinnerData(NumericUpDown numericUpDown, Option option) {
      numericUpDown.Enabled = option.IsEnabled;
    }

    private void ReadSliderData(TrackBar trackbar, Option option) {
      trackbar.Enabled = option.IsEnabled;
    }

    private void ReadComboboxData(ComboBox combobox, Option option) {
      combobox.SelectedItem = option.Value;
      combobox.Enabled = option.IsEnabled;
    }

    private void ReadCheckboxData(CheckBox checkbox, Option option) {
      checkbox.Enabled = option.IsEnabled;
      checkbox.Checked = (bool) option.Value;
    }


    /// <summary>
    /// Layouts sub-components 
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="args"></param>
    public void RecomputeSizes(object sender, EventArgs args) {

      rootPanel.HorizontalScroll.Maximum = 0;
      //exactly so (strange winform behaviour)
      rootPanel.AutoScroll = false;
      rootPanel.AutoScroll = true;

      //change splitPanel Sizes
      foreach (Control control in rootPanel.Controls) {
        SplitContainer split;
        if (control is SplitContainer) {
          split = (SplitContainer) control;
        } else if (control is Panel) {
          Panel panel = (Panel) control;
          panel.Width = rootPanel.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight);
          RecomputeComponentSize(panel);
          continue;
        } else {
          continue;
        }

        // change children of main level
        foreach (Control optionControl in split.Panel2.Controls) {
          if (optionControl is GroupBox) {
            GroupBox groupBox = (GroupBox) optionControl;
            groupBox.Width = split.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight);
            foreach (Control groupControl in groupBox.Controls) {
              if (groupControl is Panel) {
                Panel panel = (Panel) groupControl;
                panel.Width = groupBox.Width - (gbPaddingLeft + gbPaddingRight);
                RecomputeComponentSize(panel);
              } 
            }
          } else if (optionControl is RichTextBox) {
            // rtf boxes can be isolated
            RichTextBox text = (RichTextBox) optionControl;
            text.Width = split.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight);
            text.BorderStyle = BorderStyle.None;
            text.ScrollBars = RichTextBoxScrollBars.None;
            var content = text.Rtf;
            text.Text = String.Empty;
            ContentsResizedEventHandler text_OnContentsResized = null;
            text_OnContentsResized = delegate (object o, ContentsResizedEventArgs e) {
              text.Height = e.NewRectangle.Height;
              text.ContentsResized -= text_OnContentsResized;
            };
            text.ContentsResized += text_OnContentsResized;
            text.Rtf = content;

          } else if (optionControl is Panel) {
            Panel panel = (Panel) optionControl;
            panel.Width = split.Width - (topLevelGroupPaddingLeft + topLevelGroupPaddingRight);
            RecomputeComponentSize(panel);
          }
        }
      }
    }


    // Adjusts the component width in case the splitPanel was modified by the user
    private void RecomputeComponentSize(Panel panel) {
      if (panel.Controls[1] is ComboBox) {
        var combobox = (ComboBox) panel.Controls[1];
        combobox.Location = new Point(panel.Width - (topLevelGroupPaddingRight + combobox.Width), combobox.Location.Y);
      } else if (panel.Controls[1] is CheckBox) {
        var checkBox = (CheckBox) panel.Controls[1];
        checkBox.Location = new Point(panel.Width - (topLevelGroupPaddingRight + checkBox.Width), checkBox.Location.Y);
      } else if (panel.Controls[1] is NumericUpDown) {
        var spinner = (NumericUpDown) panel.Controls[1];
        spinner.Location = new Point(panel.Width - (topLevelGroupPaddingRight + spinner.Width), spinner.Location.Y);
      } else if (panel.Controls[1] is TrackBar) {
        var trackBar = (TrackBar) panel.Controls[1];
        var numericField = panel.Controls[2];
        trackBar.Width = panel.Width - (topLevelGroupPaddingRight + topLevelGroupPaddingLeft + panel.Controls[2].Width);
        numericField.Location = new Point(panel.Width - (numericField.Width + topLevelGroupPaddingRight), 20);
      } 
    }
  }
}
